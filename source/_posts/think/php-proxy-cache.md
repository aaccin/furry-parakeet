title: 聊聊缓存，PHP在7层应用层，数据库反射缓存设计
date: 2016-06-29 15:13:17
tags: [php, think, cache]
---

## 缓存

大并发情况下，缓存是一道有力的防线，缓存可以降低延迟，减轻数据库负载

但缓存也存在一些比较难的问题：

1. 缓存数据的更新，实时性
2. 缓存存储key没有考虑周全，隐私暴露
3. 缓存产生的问题bug，难以找到
4. 缓存失效重建过程，防止雪崩效应

## 缓存协议－MESI协议

MESI是Modified、Exclusive、Shared、Invalid的首字母缩写，代表四种缓存状态

* 失效（Invalid）*

要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。

* 共享（Shared）*

它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。

* 独占（Exclusive）*

和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。

* 已修改（Modified）*

属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。


MESI定律：在所有的脏缓存段（M状态）被回写后，任意缓存级别的所有缓存段中的内容，和它们对应的内存中的内容一致。此外，在任意时刻，当某个位置的内存被一个处理器加载入独占缓存段时（E状态），那它就不会再出现在其他任何处理器的缓存中。


## 缓存存储设计原则

1. 优先存原子数据，大对象数据存储，会在大并发，高负载的情况下，可能会使得服务器的CPU崩溃
2. 多线程创建缓存情况下，必要加锁来保证数据一致性
3. 对父子对象采取统一与单独混用的存储方式
4. 在连续存储中进行更新或删除后及时更新相应缓存对象



<!-- more -->


## 基本思路

缓存由用户生产，由服务生成，并实时刷新

* 实时，保证效率同时，并保障数据的及时性
* 自动，无需繁琐开发

## 实现

### 反射

待续...
